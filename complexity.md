Задача 1.
Оптимальная сложность:
    Время: O(m + n) (два прохода по каждому списку).
    Память: O(1) (константное использование дополнительной памяти).

Задача 2.
Оптимальная сложность:
Время: $O(n)$, где $n$ — длина дробной части (количество итераций цикла while).
Каждый остаток обрабатывается один раз, так как при повторе остатка цикл прерывается, что обеспечивает линейную сложность.

Память:$O(n)$, так как в худшем случае необходимо сохранить все уникальные остатки в массиве $remainderMap, чтобы обнаружить циклы.
В случае повторяющихся остатков память используется только для хранения этих остатков и их позиций, что в худшем случае равно длине дробной части.