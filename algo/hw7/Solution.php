<?php

/**
 * Definition for a singly-linked list.
 * class ListNode {
 *     public $val = 0;
 *     public $next = null;
 *     function __construct($val = 0, $next = null) {
 *         $this->val = $val;
 *         $this->next = $next;
 *     }
 * }
 */
class Solution {

    /**
     * @note Узлы одного списка будут внедряться между узлами другого списка.
     *       В процессе работы функции в памяти не будут создаваться дополнительные ноды.
     *       В результате работы функции останется только один список, содержащий все элементы обоих списков.
     *
     * @param ListNode $list1
     * @param ListNode $list2

     * @return ListNode
     */
    function mergeTwoLists($list1, $list2) {

        // Проверяем исключительные случаи
        if ($list1 === null && $list2 === null) {
            return null;
        }

        if ($list1 === null) {
            return $list2;
        }

        if ($list2 === null) {
            return $list1;
        }

        /**
         * В зависимости от значений первых узлов каждого из списоков, определяем:
         * 1. Список, элементы которого будут внедряться в другой список.
         * 2. Голову списка (в который будут внедряться узлы списка из пункта 1).
         * Переменная $list1 всегда будет содержать объект из списка узлы которого внедряются.
         * Переменная $list2 всегда будет содержать объект из результирующего списка, голову которого вернёт функция.
         * Решено сделать таким образом, потому что класс, который реализует списки является односвязным и содержит
         * ссылку только на следующий элемент. Решено из двух списков сделать один, не сохраняя изначальные списки
         * и не добавляя новые ноды, так как это экономит память.
         */
        if ($list1->val < $list2->val) {
            $head = $list1;
            $list1 = $list2;
            $list2 = $head;
        } else {
            $head = $list2;
        }

        // Итерируемся по списку, элементы которого будем внедрять в другой список.
        while ($list1 !== null) {

            /**
             * Если у результирующего списка нету следующего элемента,
             * то в качестве следующего элемента добавляем ему текущий головной элемент списка,
             * элементы которого внедряются. А так как они отсортированы, можно сразу вернуть результат.
             */
            if ($list2->next === null) {
                $list2->next = $list1;

                return $head;
            }

            /**
             * Сравнваем значения внедряемого элемента и элемента, перед которым он должен быть внедрён.
             * Если внедряемый элемент больше, то двигаем указатель результирующего списка, пока не обойдём это условие.
             */
            if ($list1->val > $list2->next->val) {
                $list2 = $list2->next;
                continue;
            }

            // Сохраняем ссылку на следующий элемент сокращающегося списка
            $list1Next = $list1->next;

            // Меняем связи между нодами.
            $list1->next = $list2->next;
            $list2->next = $list1;
            $list2 = $list2->next;

            // Переходим к следующей итерации, если элементы из внедряемого списка ещё остались.
            $list1 = $list1Next;
        }

        return $head;
    }
}
