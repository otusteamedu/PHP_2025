# Design Patterns 1

## Шаблонный метод
	
```php
class DocumentGenerator
{
    public function __construct(
        private readonly string $documentNumber
    )
    {
    }

    public function generateFromTemplate(string $template): string
    {
        // Формируем заголовок документа
        $title = '';
        if ($this instanceof ContractGenerator) {
            $title = "Контракт № $this->documentNumber";
        }
        if ($this instanceof ReportGenerator) {
            $title = "Отчёт № $this->documentNumber";
        }

        // Заменяем шаблоны на реальные значения
        $body = '';
        if ($this instanceof ContractGenerator) {
            // Дата контракта
            $body = str_replace('#date', date('d.m.Y'), $template);
        }
        if ($this instanceof ReportGenerator) {
            // Прибыль в отчёте
            $body = str_replace('#income', (string)random_int(10, 20), $template);
        }

        // Объединяем заголовок с текстом документа
        $result = $title . PHP_EOL . $body . PHP_EOL;

        // Возвращаем результат
        return $result;
    }
}
```

```php
class ContractGenerator extends DocumentGenerator
{
}

class ReportGenerator extends DocumentGenerator
{
}
```

```php
// Тестируем код

$template = 'Дата документа: #date';
$generator = new ContractGenerator('14');

echo $generator->generateFromTemplate($template);
```

### Решение: код генераторов

```php
class ContractGenerator extends DocumentGenerator
{
    protected function getTitle(): string
    {
        return "Контракт № $this->documentNumber";
    }

    protected function processTemplate(string $template): string
    {
        return str_replace('#date', date('d.m.Y'), $template);
    }
}

class ReportGenerator extends DocumentGenerator
{
    protected function getTitle(): string
    {
        return "Отчёт № $this->documentNumber";
    }

    protected function processTemplate(string $template): string
    {
        return str_replace('#income', (string)random_int(10, 20), $template);
    }
}
```

## Стратегия

```php
class Document
{
    public function __construct(
        private readonly string $title
    )
    {
    }

    public function getTitle(): string
    {
        return $this->title;
    }
}
```

```php
class ListDocumentsResponse
{
    public function __construct(
        public readonly array $titles,
        public readonly int   $totalPrice
    )
    {
    }
}
```

```php
class ListDocumentsUseCase
{
    public function __invoke(): ListDocumentsResponse
    {
        $documents = $this->loadDocuments();
        $titles = $this->fetchTitles($documents);
        $totalPrice = $this->calculateTotalPrice($documents);

        return new ListDocumentsResponse($titles, $totalPrice);
    }

    private function loadDocuments(): array
    {
        return [
            new Document('Текст, содержащий пять длинных слов'),
            new Document('6 слов, из них 2 длинных'),
            new Document('Пара слов'),
        ];
    }

    private function fetchTitles(array $documents): array
    {
        return array_map(
            static fn(Document $document): string => $document->getTitle(),
            $documents
        );
    }

    private function calculateTotalPrice(array $documents): int
    {
        $prices = [];

        if ($_ENV['APP_PRICING_MODE'] === 'Рубль за каждое слово') {
            $prices = array_map(
                static fn(Document $document): int => count(
                    preg_split('/\s+/', $document->getTitle())
                ),
                $documents
            );
        }

        if ($_ENV['APP_PRICING_MODE'] === '2 рубля за каждое слово длиннее 3 символов') {
            $prices = array_map(
                static fn(Document $document): int => 2 * count(
                        array_filter(
                            preg_split('/\s+/', $document->getTitle()),
                            static fn(string $word): bool => mb_strlen($word) > 3
                        )
                    ),
                $documents
            );
        }

        return array_sum($prices);
    }

}
```

```php
// Тестируем алгоритм "Рубль за каждое слово"

$_ENV['APP_PRICING_MODE'] = 'Рубль за каждое слово';
$useCase = new ListDocumentsUseCase();
var_dump(($useCase)());

// Тестируем алгоритм "2 рубля за каждое слово длиннее 3 символов"

$_ENV['APP_PRICING_MODE'] = '2 рубля за каждое слово длиннее 3 символов';
$useCase = new ListDocumentsUseCase();
var_dump(($useCase)());
```

### Решение

```php
interface PriceCalculatorInterface
{
    public function calculateTotalPrice(array $documents): int;
}
```

```php
class RegularPriceCalculator implements PriceCalculatorInterface
{
    public function calculateTotalPrice(array $documents): int
    {
        $prices = array_map(
            static fn(Document $document): int => count(
                preg_split('/\s+/', $document->getTitle())
            ),
            $documents
        );
        return array_sum($prices);
    }
}

class LongWordsPriceCalculator implements PriceCalculatorInterface
{
    public function calculateTotalPrice(array $documents): int
    {
        $prices = array_map(
            static fn(Document $document): int => 2 * count(
                    array_filter(
                        preg_split('/\s+/', $document->getTitle()),
                        static fn(string $word): bool => mb_strlen($word) > 3
                    )
                ),
            $documents
        );
        return array_sum($prices);
    }
}
```

```php
interface DocumentRepositoryInterface
{
    public function findAll(): array;
}
```

```php
class InMemoryDocumentRepository implements DocumentRepositoryInterface
{
    public function findAll(): array
    {
        return [
            new Document('Текст, содержащий пять длинных слов'),
            new Document('6 слов, из них 2 длинных'),
            new Document('Пара слов'),
        ];
    }
}
```

```php
class ListDocumentsUseCase
{

    public function __construct(
        private readonly PriceCalculatorInterface    $priceCalculator,
        private readonly DocumentRepositoryInterface $documentRepository
    )
    {
    }

    public function __invoke(): ListDocumentsResponse
    {
        $documents = $this->documentRepository->findAll();
        $titles = $this->fetchTitles($documents);
        $totalPrice = $this->priceCalculator->calculateTotalPrice($documents);

        return new ListDocumentsResponse($titles, $totalPrice);
    }


    private function fetchTitles(array $documents): array
    {
        return array_map(
            static fn(Document $document): string => $document->getTitle(),
            $documents
        );
    }
}
```

```php
// Тестируем алгоритм "Рубль за каждое слово"

$useCase = new ListDocumentsUseCase(new RegularPriceCalculator(), new InMemoryDocumentRepository());
var_dump(($useCase)());

// Тестируем алгоритм "2 рубля за каждое слово длиннее 3 символов"

$useCase = new ListDocumentsUseCase(new LongWordsPriceCalculator(), new InMemoryDocumentRepository());
var_dump(($useCase)());
```

### Пример Стратегии: валидация данных

```php
interface EmailValidatorInterface
{
    public function isValid(string $email): bool;
}
```

```php
class EmailValidator implements EmailValidatorInterface
{
    public function isValid(string $email): bool
    {
        return filter_var($email, FILTER_VALIDATE_EMAIL);
    }
}

class CorporateEmailValidator implements EmailValidatorInterface
{
    public function isValid(string $email): bool
    {
        return filter_var($email, FILTER_VALIDATE_EMAIL)
            && str_ends_with($email, '@example.com');
    }
}
```

```php
interface PhoneValidatorInterface
{
    public function isValid(string $phone): bool;
}
```

```php
class RussianPhoneValidator implements PhoneValidatorInterface
{
    public function isValid(string $phone): bool
    {
        return preg_match('/^\+7\d{10}$/', $phone);
    }
}

class NoopPhoneValidator implements PhoneValidatorInterface
{
    public function isValid(string $phone): bool
    {
        return true;
    }
}
```

```php
class RegistrationForm  
{  
    public function __construct(  
        private EmailValidatorInterface $emailValidator,  
        private PhoneValidatorInterface $phoneValidator  
    ) {  
    }  
      
    public function validate(string $email, string $phone): bool {  
        return $this->emailValidator->isValid($email)   
            && $this->phoneValidator->isValid($phone);  
    }  
}
```

```php
// У пользователей должен быть любой E-mail и телефон в РФ

$userRegistrationForm = new RegistrationForm(
    new EmailValidator(),
    new RussianPhoneValidator()
);

// У менеджеров должен быть корпоративный E-mail и любой телефон

$managerRegistrationForm = new RegistrationForm(
    new CorporateEmailValidator(),
    new NoopPhoneValidator()
);
```

## Декоратор

```php
class Document  
{  
    public function __construct(  
        private readonly string $title,  
    )  
    {  
    }  
  
    public function getTitle(): string  
    {  
        echo 'DEBUG: мы внутри метода getTitle()'. PHP_EOL;  
        return $this->title;  
    }  
}
```

```php
class DocumentPresenter  
{  
    public function printDocuments(Document ...$documents)  
    {  
        foreach ($documents as $document) {  
            echo $document->getTitle() . PHP_EOL . PHP_EOL;  
        }  
    }  
}
```

```php
// Тестируем код
  
$doc1 = new Document('Контракт');  
$doc2 = new Document('Отчёт');  
  
$presenter = new DocumentPresenter();  
$presenter->printDocuments($doc1, $doc2);
```

### Логирование: наследование

```php
class LoggingDocument extends Document {  
    public function getTitle(): string {  
        echo 'Пишем в лог...'. PHP_EOL;  
        return parent::getTitle();  
    }  
}
```

```php
// Тестируем код

$doc1 = new Document('Контракт');  
$doc2 = new LoggingDocument('Отчёт');  
  
$presenter = new DocumentPresenter();  
$presenter->printDocuments($doc1, $doc2);
```

### Решение: Декоратор

```php
interface DocumentInterface  
{  
    public function getTitle(): string;  
}
```

```php
class Document implements DocumentInterface  
{  
    public function __construct(  
        private readonly string $title,  
    )  
    {  
    }  
  
    public function getTitle(): string  
    {  
        echo 'DEBUG: мы внутри метода getTitle()' . PHP_EOL;  
        return $this->title;  
    }  
}
```

```php
class LoggingDocumentDecorator implements DocumentInterface  
{  
    public function __construct(  
        private readonly DocumentInterface $document  
    )  
    {  
    }  
  
    public function getTitle(): string  
    {  
        echo 'Пишем в лог...' . PHP_EOL;  
        return $this->document->getTitle();  
    }  
}
```

```php
class NormalizingDocumentDecorator implements DocumentInterface  
{  
    public function __construct(  
        private readonly DocumentInterface $document  
    )  
    {  
    }  
  
    public function getTitle(): string  
    {  
        echo 'Запрашиваем заголовок для нормализации...' . PHP_EOL;  
        $title = $this->document->getTitle();  
        echo 'Нормализуем заголовок...' . PHP_EOL;  
        return mb_strtoupper($title);  
    }  
}
```

```php
class DocumentPresenter  
{  
    public function printDocuments(DocumentInterface ...$documents)  
    {  
        foreach ($documents as $document) {  
            echo $document->getTitle() . PHP_EOL . PHP_EOL;  
        }  
    }  
}
```

```php
// Тестируем код

$doc1 = new Document('Контракт');  
$doc2 = new Document('Отчёт');  
  
$loggedDoc1 = new LoggingDocumentDecorator($doc1);  
$normalizedAndLoggedDoc2 = new NormalizingDocumentDecorator(new LoggingDocumentDecorator($doc2));  
  
$presenter = new DocumentPresenter();  
$presenter->printDocuments($loggedDoc1, $normalizedAndLoggedDoc2);
```

### Пример: оповещения

```php
interface NotificationInterface  
{  
    public function send();  
}
```

```php
class EmailNotification implements NotificationInterface  
{  
    public function send()  
    {  
        echo 'Отправка сообщения: E-mail' . PHP_EOL;  
    }  
}  
  
class SmsNotification implements NotificationInterface  
{  
    public function send()  
    {  
        echo 'Отправка сообщения: SMS' . PHP_EOL;  
    }  
}  
  
class TelegramNotification implements NotificationInterface  
{  
    public function send()  
    {  
        echo 'Отправка сообщения: Telegram' . PHP_EOL;  
    }  
}
```

```php
class User  
{  
    public function __construct(  
        private readonly NotificationInterface $notification 
    )  
    {  
    }  
  
    public function notify(): void  
    {  
        $this->notification->send();  
    }  
}
```

```php
// Тестирование кода  
  
$notification = new EmailNotification();  
$user = new User($notification);  
$user->notify();
```

```php
class MultipleNotification implements NotificationInterface  
{  
    public function __construct(  
        private readonly array $notifications
    )  
    {  
    }  
  
    public function send(): void  
    {  
        foreach ($this->notifications as $notification) {  
            $notification->send();  
        }  
    }
```

```php
// Тестирование кода  
  
$notification = new MultipleNotification(  
    [  
        new EmailNotification(),  
        new SmsNotification(),  
    ]  
);  
$user = new User($notification);  
$user->notify();
```

## Прокси

```php
class Document  
{  
    private string $title;  
    private array $reviews;  
  
    public function __construct(string $title, array $reviews)  
    {  
        $this->title = $title;  
        $this->reviews = $reviews;  
    }  
  
    public function getTitle(): string  
    {  
        return $this->title;  
    }  
  
    public function getReviews(): array  
    {  
        return $this->reviews;  
    }  
}
```

```php
class DocumentRepository  
{  
    public function findById(int $id): ?Document  
    {  
        $title = 'Контракт';  
        // Имитация загрузки данных из API  
        sleep(3);  
        $reviews = [  
            '*****',  
            '*****',  
            '****',  
        ];  
        return new Document($title, $reviews);  
    }  
}
```

```php
class DocumentPresenter  
{  
    public function printDocumentTitle(Document $document): void  
    {  
        echo $document->getTitle() . PHP_EOL;  
    }  
  
    public function printDocumentReviews(Document $document): void  
    {  
        echo implode(', ', $document->getReviews()) . PHP_EOL;  
    }  
}
```

```php
// Тестируем код  
  
$documentRepository = new DocumentRepository();  
$documentPresenter = new DocumentPresenter();  
  
$document = $documentRepository->findById(1);  
  
$documentPresenter->printDocumentTitle($document);  
$documentPresenter->printDocumentReviews($document);
```

### Решение: Прокси

```php
class DocumentProxy extends Document  
{  
    // Это поле "перекрывает" $review из родительского класса,  
    // но не перезаписывает его!
    private ?array $reviews = null;  
  
    public function __construct(string $title)  
    {  
        parent::__construct($title, []);  
    }  
  
    public function getReviews(): array  
    {  
        // Загружаем отзывы из API только в том случае,  
        // если кто-нибудь ВПЕРВЫЕ вызвал этот метод
        if ($this->reviews === null) {  
            // Имитация загрузки данных из API
            sleep(3);  
            $reviews = [  
                '*****',  
                '*****',  
                '****',  
            ];  
            // Кешируем результат  
            $this->reviews = $reviews;  
        }  
  
        return $this->reviews;  
    }  
}
```

```php
class DocumentRepository  
{  
    public function findById(int $id): ?Document  
    {  
        $title = 'Контракт';  
        return new DocumentProxy($title);  
    }  
}
```

## Ссылка на опрос

```
https://otus.ru/polls/117243/
```