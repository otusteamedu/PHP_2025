# PHP_2025

https://otus.ru/lessons/razrabotchik-php/?utm_source=github&utm_medium=free&utm_campaign=otus

# Задания

## Преобразование дроби в повторяющуюся десятичную дробь

https://leetcode.com/problems/fraction-to-recurring-decimal/description/

Если заданы два целых числа, представляющие числитель и знаменатель дроби, верните дробь в формате строки.
Если дробная часть повторяется, заключите повторяющуюся часть в круглые скобки.
Если возможно несколько вариантов ответа, верните любой из них.
Гарантируется, что длина строки ответа будет меньше 104 для всех заданных входных данных.

Пример 1:
Ввод: числитель = 1, знаменатель = 2
Вывод: "0.5"

Пример 2:
Входные данные: числитель = 2, знаменатель = 1
Выходные данные: "2"

Пример 3:
Входные данные: числитель = 4, знаменатель = 333
Выходные данные: "0.(012)"
 
Ограничения:
-231 <= числитель, знаменатель <= 231 - 1
знаменатель != 0

## Пересечение двух связанных списков

https://leetcode.com/problems/intersection-of-two-linked-lists/description/

Учитывая заголовки двух односвязных списков headA и headB, верните узел, в котором эти два списка пересекаются. Если два связанных списка вообще не пересекаются, верните значение null.

Например, два следующих связанных списка начинают пересекаться в узле c1:
Тестовые примеры генерируются таким образом, чтобы нигде во всей связанной структуре не было циклов.
Обратите внимание, что связанные списки должны сохранять свою первоначальную структуру после возврата функции.

Пользовательский судья:
Входные данные для судьи задаются следующим образом (в вашей программе эти входные данные не задаются):
intersectVal - Значение узла, в котором происходит пересечение. Это значение равно 0, если пересеченного узла нет.
listA - Первый связанный список.
listB - Второй связанный список.
skipA - количество узлов, которые нужно пропустить вперед в listA (начиная с верхнего), чтобы добраться до пересекаемого узла.
skipB - количество узлов, которые нужно пропустить вперед в списке B (начиная с начала), чтобы добраться до пересекаемого узла.
Затем эксперт создаст связанную структуру на основе этих входных данных и передаст две вершины, headA A и headB, в вашу программу. Если вы правильно вернете пересеченный узел, то ваше решение будет принято.

Пример 1:
Входные данные: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Выходные данные: Пересечено в точке "8"
Пояснение: Значение пересекаемого узла равно 8 (обратите внимание, что оно не должно быть равно 0, если два списка пересекаются).
Из заголовка A это читается как [4,1,8,4,5]. Из заголовка B это читается как [5,6,1,8,4,5]. Есть 2 узла перед пересекающимся узлом в A; Есть 3 узла перед пересекающимся узлом в B.
- Обратите внимание, что значение пересекаемого узла не равно 1, поскольку узлы со значением 1 в A и B (2-й узел в A и 3-й узел в B) являются ссылками на разные узлы. Другими словами, они указывают на два разных места в памяти, в то время как узлы со значением 8 в A и B (3-й узел в A и 4-й узел в B) указывают на одно и то же место в памяти.

Пример 2:
Входные данные: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Выходные данные: Пересечено в точке "2"
Пояснение: Значение пересекаемого узла равно 2 (обратите внимание, что оно не должно быть равно 0, если два списка пересекаются).
В начале A оно читается как [1,9,1,2,4]. В начале строки B это читается как [3,2,4]. Перед пересекающимся узлом в A есть 3 узла; перед пересекающимся узлом в B есть 1 узел.

Пример 3:
Входные данные: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Выходные данные: Пересечения нет
Пояснение: В начале строки A это читается как [2,6,4]. В начале строки B это читается как [1,5]. Поскольку два списка не пересекаются, intersectVal должно быть равно 0, в то время как skipA и skipB могут быть произвольными значениями.
Пояснение: Два списка не пересекаются, поэтому возвращайте значение null.
 
Ограничения:
Количество узлов listA указано в m.
Количество узлов в списке b равно n.
1 <= m, n <= 3 * 104
1 <= Node.val <= 105
0 <= skipA <= m
0 <= skipB <= n
intersectVal равно 0, если listA и listB не пересекаются.
intersectVal == listA[skipA] == listB[skipB], если listA и listB пересекаются.
 
Продолжение: Не могли бы вы написать решение, которое выполнялось бы за O (m + n) времени и использовало бы только O(1) памяти?

