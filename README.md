# PHP_2025

https://otus.ru/lessons/razrabotchik-php/?utm_source=github&utm_medium=free&utm_campaign=otus

Домашнее задание по лекции 24 Unit-тестирование Разработка кейсов тестирования

## Модульные тесты для бэкенда
Позитивный тест/happy path:
Если подать на вход бэкенда json-объектом
{
	card_number: 16 цифр,
	card_holder: 2 слова латиницей разделённые пробелом,
	card_expiration: строка в формате `мм/гг`,
	cvv: строка 3 цифры,
	order_number: 16 любых символов цифра или буква,
	sum: строка 00,00 
},
то бэкенд отправляет запрос сервису A.

Негативные тесты:
Проверки на...
**card_number**
- соответствие формату `/^\d{16}$/` (строка , 16 цифр подряд)
- отсутвуют любые другие символы кроме цифр, в том числе пробел и дефис
- строка не пустая и это не null

**card_holder**
- соответствие формату /^[A-Z]+ [A-Z]+$/  (строка, только латинские буквы и один пробел)
- есть только один пробел
- длинна строки не больше 256 символов
- строка не пустая и это не null

**card_expiration**
- соответствие формату `/^(0[1-9]|1[0-2])\/\d{2}$/` (строка в формате MM/ГГ)
- проверка на истёкшую дату
- строка не пустая и это не null

**cvv**
- соответствие формату `/^\d{3}$/` (3 цифры)
- строка не пустая и это не null

**order_number**
- соответствие формату `/^\d{1,16}$/` (от 1 до 16 цифр)
- не больше 16 символов в строке
- строка не пустая и это не null
- проверка что такой номер присутствует в базе

**sum**
- соответствие формату `/^\d+,\d{2}$/` (строка в формате 00,00 . Разрешены только цифры и одна запятая, после запятой только два разряда(копейки). Запись копеек обязательная)
- проверка что сумме не 0,00
- строка не пустая и это не null

Во всех случаях если проверки не пройдены -> на фронте подсвечиваем соответствующее поле ввода красным и выводим сообщение "неверный формат введённых данных".
Если на бэке происходит ошибка вычислений -> бэк возвращает 500 и на фронте выводим "ошибка обработки платежных данных, повторите позднее".

## Интеграционные тесты
1. Проверка связки бэк <-> фронт
Положительный тест: Если фронт отправялет корректный json -> бэк отправляет данные сервису А
Отрицательный тест: Если бэк не отвечает то фронт выводит ошибку 500

2. Проверка связки бэк <-> Cервиса А
Положительный тест: Если бэк отправляет запрос сервису A, он начинает проверки 
Негативные тесты:
- Ошибка сети / таймаут от Сервиса A / сервис А не отвечает → бэк пробрасывает ошибку на фронт  
- Если недостаточно средств -> Сервис A возвращает ошибку и бэк пробрасывает ошибку на фронт 
- Если карта заблокирована -> Сервис A возвращает ошибку и бэк пробрасывает ошибку на фронт

3. Проверка Репозитория
Положительный тест: Если сервис A возвращает положительный ответ в репозитории вызывается метод setOrderIsPaid
Негативные тесты:
- Если БД недоступна -> на фронт пробрасывается 500 ошибка 
- Если номер заказа и/или сумма из сервиса А не совпадают с значением в базе -> на фронт пробрасывается 500 ошибка 
- Если пришел повторный номер заказа -> отклонить заказ, вернуть деньги если списались, отправить сообщение на фронт о ошибке. 


## Системные тесты

1. Проверка успешного пути целиком.
- правильно введённые на фронте данные
- корректный запрос от фронта к бэку
- бэк шлёт запрос в сервис А
- сервис А шлёт 200 в Репозиторий
- метод setOrderIsPaid подтверждает заказ
- репозиторий шлёт 200 на бэк, а тот на фронт
- на фронте появляется сообщение об успешной оплате
2. Проверка что сервис отклоняет платёж и на фронт приходит ошибка при
- Недостаточном кол-ве денег на карте
- Карта заблокирована
- Карта недействительна
- Неверен cvv
3. Если сервис А вернул успешную оплату, а заказа в базе не нашлось, оплата должна корректно отменится с сообщением на фронт.

Для удешевления тестирования можно подключить тестовый баланс в платёжном сервисе и/или добавить скрытый товар за один рубль. 