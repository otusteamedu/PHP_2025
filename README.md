# ДЗ №16 - Unit-тестирование

## Модули системы

1. Бэк
2. Фронт
3. Репозиторий
4. Сервис A.

## Кейсы тестирования системы оплаты фильмов

### 1. Модульные тесты (Unit Tests)

__Объект тестирования:__ Метод контроллера (его валидация и основная логика).

__Цель:__ Проверить, что метод контроллера корректно валидирует входные данные и правильно обрабатывает ответы от
зависимостей (сервиса А и репозитория) в изоляции. Зависимости заменяются моками (заглушками).

#### 1.1. Валидация входных данных (ожидаемый результат: HTTP 400):

##### Валидация card_number, если

- __менее 16 цифр__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __более 16 цифр__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит буквы или другие символы__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __пустая строка__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит NULL__, то тестируемый метод возвращает 400 с сообщением об ошибке;

##### Валидация card_holder, если

- __пустая строка__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит null__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит цифры__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит спецсимволы__, кроме дефиса и пробела (например, @, !), то тестируемый метод возвращает 400 с сообщением об
  ошибке;
- __содержит кириллицу__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит более одного пробела подряд (например, John Doe)__, то тестируемый метод возвращает 400 с сообщением об
  ошибке;
- __начинается или заканчивается пробелом/дефисом__, то тестируемый метод возвращает 400 с сообщением об ошибке;

##### Валидация card_expiration, если

- __имеет неверный формат (например, мм-гг, 12/2025)__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __месяц больше 12__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __месяц меньше 1__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит прошедшую дату (например, 01/20 при текущей дате 05/24)__, то тестируемый метод возвращает 400 с сообщением
  об ошибке;
- __пустая строка__, то тестируемый метод возвращает 400 с сообщением об ошибке;

##### Валидация cvv, если

- __менее 3 цифр__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __более 3 цифр__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __содержит нечисловые символы__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __пустая строка__, то тестируемый метод возвращает 400 с сообщением об ошибке;

##### Валидация order_number, если

- __пустая строка__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __null__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __длина более 16 символов__, то тестируемый метод возвращает 400 с сообщением об ошибке;

##### Валидация sum, если

- __неверный формат (например, 100.50, 100 руб.)__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __отрицательное число (-100,00)__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __ноль (0,00)__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __пустая строка__, то тестируемый метод возвращает 400 с сообщением об ошибке;
- __null__, то тестируемый метод возвращает 400 с сообщением об ошибке;

#### 1.2. Взаимодействие с зависимостями (мокируются Сервис А и Репозиторий)

__Успех:__ Сервис А возвращает 200 -> Репозиторий возвращает true -> Контроллер возвращает успех (например, 200 или
201).

__Ошибка Сервиса А:__ Данные валидны, но Сервис А возвращает 403 -> Контроллер возвращает 403 с сообщением об ошибке от
сервиса (или общим).

__Ошибка Репозитория:__

- Данные валидны, Сервис А возвращает 200, но Репозиторий возвращает false (например, сумма не совпала) -> Контроллер
  должен вернуть ошибку (например, 500 или 400).
- Данные валидны, Сервис А возвращает 200, но Репозиторий выбрасывает исключение (например, заказ не найден) ->
  Контроллер должен обработать исключение и вернуть соответствующий HTTP-код (например, 404 или 500).

#### 1.3. Позитивный тест (мокируются Сервис А и Репозиторий)

__Успех:__ Все входные данные абсолютно валидны (корректный номер карты, владелец `John Doe`, будущая дата `12/28`,
верный
`cvv`, адекватный `order_number`, положительная `sum`).

- __Моки:__ Сервис А возвращает HTTP 200. Репозиторий setOrderIsPaid возвращает true.
- __Ожидаемый результат:__ Метод контроллера возвращает код успеха (например, `HTTP 200` или `201`) и ожидаемые данные в
  теле ответа (например, `{"status": "success"}`). __Убедиться, что метод репозитория был вызван ровно 1 раз с правильными
  аргументами.__

### 2. Интеграционные тесты (Integration Tests)

__Цель:__ Проверить взаимодействие между двумя и более модулями.

#### 2.1. Связка «Фронтенд — Бэкенд» (Frontend — Backend):

- __Кейс 1 (Ошибка валидации):__ Фронтенд отправляет JSON с card_holder, содержащим цифры. Бэкенд возвращает 400 с
  описанием ошибки. Фронтенд выделяет поле «Владелец карты» красной рамкой и показывает сообщение об ошибке из ответа.

- __Кейс 2 (Успех):__ Фронтенд отправляет корректные данные. Бэкенд возвращает 200 OK. Фронтенд показывает пользователю
  сообщение об успешной оплате и перенаправляет его на страницу успеха.

- __Кейс 3 (Ошибка оплаты):__ Фронтенд отправляет корректные, но «отклоняемые» сервисом А данные (например, недостаточно
  средств). Бэкенд возвращает 403. Фронтенд показывает общее сообщение типа «Не удалось провести оплату. Проверьте
  реквизиты или попробуйте позже».

#### 2.2. Связка «Бэкенд — Сервис А» (Backend — Service A):

- __Кейс 1:__ Бэкенд отправляет корректно сформированный HTTP-запрос (с правильными заголовками, телом в нужном формате)
  с
  валидными данными карты. Используется тестовый (песочница) API-ключ Сервиса А. Убедиться, что запрос доходит и ответ (
  200/403) корректно парсится бэкендом.

- __Кейс 2:__ Бэкенд отправляет запрос с заведомо «недостаточной суммой» (специальный тестовый номер карты в песочнице
  Сервиса
  А, который имитирует ошибку 403). Убедиться, что бэкенд корректно обрабатывает этот ответ и не пытается вызвать метод
  репозитория.

#### 2.3. Связка «Бэкенд — Репозиторий (БД)» (Backend — Repository):

- __Кейс 1:__ После успешного ответа от Сервиса А (200) бэкенд вызывает setOrderIsPaid($orderNumber, $sum) с корректными
  аргументами. Убедиться, что запись в БД обновляется (например, у заказа проставляется статус paid).

- __Кейс 2:__ Бэкенд вызывает setOrderIsPaid с несуществующим $orderNumber. Репозиторий выбрасывает исключение.
  Убедиться, что
  бэкенд корректно его ловит, логирует и возвращает пользователю понятный HTTP-код (например, 500 или 404), а также
  откатывает транзакцию (если она есть), чтобы не списывать деньги за несуществующий заказ.

### 3. Системные тесты (End-to-End Tests, E2E)

__Цель:__ Проверить работу всей системы целиком в среде, максимально приближенной к боевой. Фронтенд, бэкенд,
репозиторий и
песочница (test environment) Сервиса А развернуты и работают вместе.

#### 3.1. Кейс 1 (Счастливый путь):

1. Пользователь вводит на фронтенде тестовые данные карты (предоставленные Сервисом А для успешной оплаты, например,
   5555 5555 5555 4444), валидные дату, CVV, номер заказа и сумму.
2. Нажимает «Оплатить».
3. Ожидаемый результат: На фронтенде отображается сообщение об успешной оплате. В БД у соответствующего заказа
   проставлен статус paid.

#### 3.2. Кейс 2 (Ошибка оплаты на стороне Сервиса А):

1. Пользователь вводит на фронтенде тестовые данные карты для имитации ошибки (например, 4000 0000 0000 0002 для
   имитации отказа).
2. Нажимает «Оплатить».
3. Ожидаемый результат: На фронтенде отображается сообщение об ошибке оплаты (без технических деталей). В БД статус
   заказа не меняется на paid.

#### 3.3. Кейс 3 (Проверка консистентности обработки ошибок):

1. Вызвать несколько разных ошибок валидации (например, неверный номер карты, неверный срок действия).
2. Ожидаемый результат: Фронтенд для любой ошибки валидации ведет себя единообразно: выделяет проблемное поле красной
   рамкой и показывает текст ошибки рядом с ним. Поведение не должно отличаться (не должно быть случаев, когда ошибка
   приводит к падению фронтенда).

#### 3.4. Кейс 4 (Проверка отсутствия двойного списания):

1. Отправить два одинаковых запроса на оплату с одинаковым order_number подряд.
2. Ожидаемый результат: Первый запрос успешен. Второй запрос должен быть отклонен либо на этапе валидации бэкенда (
   проверка статуса заказа в БД перед обращением к Сервису А), либо на этапе вызова setOrderIsPaid (который вернет
   false). Деньги должны быть списаны только один раз. Это критически важный для бизнеса кейс.

### Способы удешевления тестирования

1. __Использование Песочницы (Sandbox) Сервиса А:__ Все тесты, кроме, возможно, финального этапа приемочного
   тестирования (UAT), должны использовать тестовое API Сервиса А. Оно предоставляет специальные номера карт для
   симуляции различных сценариев (успех, недостаточно средств, отказ банка и т.д.) без реального списания денег.

2. __Изоляция дорогих тестов:__ E2E-тесты часто медленные и дорогие. Необходимо:
    - Запускать их не на каждое изменение кода, а, например, ночью или перед выпуском в прод.
    - Четко отделять модульные и интеграционные тесты (которые работают быстро и без внешних сервисов) от системных.
    - Использовать тестовую БД для интеграционных и E2E-тестов, которая очищается перед каждым прогоном.

3. __Мокирование в Модульных и Интеграционных тестах:__ Как уже указано в модульных тестах, Сервис А и Репозиторий
   должны быть замоканы. Это позволяет тестировать логику бэкенда без реальных вызовов к API и БД, что бесплатно и
   мгновенно.

4. __Тестирование на пониженных суммах:__ Если песочница Сервиса А позволяет имитировать успешную оплату с суммой
   0.01 (или аналогичной минимальной), используйте это в тестах вместо реальных сумм заказов.
