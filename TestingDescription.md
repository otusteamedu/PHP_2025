# Модульные тесты (Unit Tests)
На этом уровне мы тестируем бэк в изоляции, в частности — валидацию входных данных в контроллере. 
Для этого идеально подходит PHPUnit с использованием DataProvider для подачи на вход различных наборов данных.


```php
<?php

namespace Tests\Unit;

use App\Http\Controllers\PaymentController;
use PHPUnit\Framework\TestCase;

class PaymentControllerTest extends TestCase
{
    /**
     * @dataProvider invalidDataProvider
     */
    public function test_validation_fails_with_invalid_data(array $data, string $expectedErrorField): void
    {
        // Arrange: Создаем экземпляр контроллера
        $controller = new PaymentController(/* ...зависимости... */);

        // Act: Вызываем метод обработки платежа
        $response = $controller->processPayment($data);

        // Assert: Проверяем, что получен ответ с кодом 400
        // и сообщение об ошибке содержит указание на неверное поле
        $this->assertEquals(400, $response->getStatusCode());
        $this->assertStringContainsString($expectedErrorField, $response->getContent());
    }

    public static function invalidDataProvider(): array
    {
        return [
            // Кейсы для card_number
            'card_number_too_short' => [['card_number' => '123456789012345'], 'card_number'],
            'card_number_contains_letters' => [['card_number' => '123456789012345a'], 'card_number'],
            'card_number_is_null' => [['card_number' => null], 'card_number'],

            // Кейсы для card_holder
            'card_holder_is_empty' => [['card_holder' => ''], 'card_holder'],
            'card_holder_contains_digits' => [['card_holder' => 'John Doe 1'], 'card_holder'],
            'card_holder_contains_cyrillic' => [['card_holder' => 'Иван Иванов'], 'card_holder'],
            'card_holder_multiple_spaces' => [['card_holder' => 'John  Doe'], 'card_holder'],

            // Кейсы для card_expiration
            'expiration_invalid_format' => [['card_expiration' => '12-25'], 'card_expiration'],
            'expiration_month_invalid' => [['card_expiration' => '13/25'], 'card_expiration'],
            'expiration_date_in_past' => [['card_expiration' => '01/20'], 'card_expiration'],

            // Кейсы для cvv
            'cvv_not_a_digit' => [['cvv' => 'a12'], 'cvv'],
            'cvv_too_long' => [['cvv' => '1234'], 'cvv'],

            // Кейсы для sum
            'sum_is_not_a_valid_float_string' => [['sum' => '100.50'], 'sum'], // Ожидается запятая
            'sum_is_negative' => [['sum' => '-100,00'], 'sum'],
        ];
    }

    public function test_payment_processed_successfully_with_valid_data(): void
    {
        // Этот тест относится уже к интеграционным, так как он
        // будет проверять взаимодействие с другими сервисами.
        // В модульных тестах мы фокусируемся на отказах валидации.
    }
}
```

# Интеграционные тесты

Здесь мы проверяем взаимодействие между модулями. Для изоляции связок используются моки (Mocks) — объекты-заглушки.

**Связка «Бэк — Сервис А»**

Цель: Убедиться, что бэк правильно обрабатывает ответы от платёжного сервиса.

1.  Кейс: Успешное списание (HTTP 200).
    *   Описание: Создаём мок клиента для Сервиса А, который на любой запрос возвращает HTTP-ответ 200. Подаём на вход контроллера валидные данные.
    *   Проверка (Assert): Убеждаемся, что после вызова Сервиса А бэк вызывает метод репозитория setOrderIsPaid().
2.  Кейс: Неуспешное списание (HTTP 403).
    *   Описание: Мок клиента для Сервиса А настроен на возврат HTTP-ответа 403 (например, "недостаточно средств").
    *   Проверка (Assert): Бэк возвращает клиенту (фронту) ответ с кодом 403 и не вызывает метод setOrderIsPaid().

**Связка «Бэк — Репозиторий»**

Цель: Проверить, как бэк реагирует на результат записи в БД после успешной оплаты.

1.  Кейс: Успешная запись в БД.
    *   Описание: Мок Сервиса А возвращает 200. Мок Репозитория на вызов setOrderIsPaid() возвращает true.
    *   Проверка (Assert): Бэк возвращает фронту ответ с кодом 200 и сообщением об успешной оплате.
2.  Кейс: Ошибка записи в БД.
    *   Описание: Мок Сервиса А возвращает 200. Мок Репозитория на вызов setOrderIsPaid() выбрасывает исключение (например, PDOException).
    *   Проверка (Assert): Бэк должен отловить это исключение, залогировать его и вернуть фронту ответ с кодом 500 (Internal Server Error), чтобы пользователь не видел деталей ошибки БД.

**Связка «Фронт — Бэк»**

Цель: Убедиться, что фронтенд корректно отображает результаты, полученные от бэкенда. Тесты пишутся на стороне фронтенда (например, с помощью Jest или Cypress), но мы опишем их концептуально.

1.  Кейс: Ошибка валидации на бэке.
    *   Описание: Пользователь вводит номер карты из 15 цифр и нажимает "Оплатить". Бэк возвращает 400 Bad Request с указанием на поле card\_number.
    *   Проверка: На фронтенде поле "Номер карты" подсвечивается красной рамкой и под ним появляется текст ошибки, полученный от бэка.
2.  Кейс: Успешная оплата.
    *   Описание: Пользователь вводит валидные данные, бэк возвращает 200 OK.
    *   Проверка: Фронтенд скрывает форму оплаты и показывает сообщение "Оплата прошла успешно!".

# Системные тесты

Это end-to-end тесты, которые эмулируют действия реального пользователя в системе, где все модули работают вместе. Для них часто используют браузерные автоматизаторы (Selenium, Cypress).

*   Кейс "Счастливый путь" (Happy Path).
    *   Действия:
        1.  Пользователь открывает страницу оплаты.
        2.  Заполняет все поля формы валидными тестовыми данными карты.
        3.  Нажимает кнопку "Оплатить".
    *   Ожидаемый результат:
        1.  Платёжный сервис (в тестовом режиме) одобряет транзакцию.
        2.  В базе данных появляется запись об оплате заказа.
        3.  Пользователь видит на экране сообщение "Спасибо за покупку!".
*   Кейс "Отклонено платёжной системой".
    *   Действия:
        1.  Пользователь открывает страницу оплаты.
        2.  Заполняет все поля, но использует номер карты, который по правилам тестового окружения Сервиса А всегда отклоняется (например, из-за недостатка средств).
        3.  Нажимает кнопку "Оплатить".
    *   Ожидаемый результат:
        1.  Пользователь остаётся на странице оплаты.
        2.  Появляется сообщение: "Не удалось списать средства. Проверьте данные карты или используйте другую".
        3.  Запись об оплате в БД не создаётся.

# Удешевление тестирования

Поскольку речь идёт о реальных деньгах, важно минимизировать затраты:

*   Использование Sandbox-окружения: Платёжный сервис «А» должен предоставлять тестовую среду (песочницу), которая полностью имитирует боевую, но не проводит реальных финансовых транзакций.
*   Тестовые номера карт: Все платёжные системы (Visa, Mastercard и др.) предоставляют специальные номера карт для тестирования. Эти карты позволяют проверять различные сценарии: успешная оплата, недостаточно средств, карта заблокирована и т.д.
*   Минимальная сумма: Если тестирование в производственной среде неизбежно (например, для дымовых тестов), его следует проводить с минимально возможной суммой (например, 1 рубль).